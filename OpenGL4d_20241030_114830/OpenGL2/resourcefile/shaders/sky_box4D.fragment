#version 440
#define PI 3.1415926535f
in vec4 vs_position;
in vec3 vs_texcoord;
out vec4 fs_color;

//Uniforms
layout (binding = 4) uniform sampler3D diffuse3D;
layout (binding = 5) uniform sampler3D starsField3D;
layout (binding = 9) uniform sampler3D area;
layout (binding = 11) uniform sampler3D deleteMap3D;

uniform int type;
uniform vec4 paintingColor;
uniform bool isAreaDeleting=false;
uniform bool isCloud;
uniform bool isSkyBoxFog;
uniform float iTime;
struct DirectionLight4D
{
	vec4 direction4D;
	float intensity;
	vec3 color;
};
uniform DirectionLight4D directionLight4D;
uniform vec4 cameraPos;
vec4 color;
vec4 direction;
vec3 uv,uv2,a,a2;
float extreme;
float cloudDistance,transmittance;
float direction2,directionFinal2;

float calculate_direction(vec4 vs_normal, vec4 direction)
{
	directionFinal2 = -dot(normalize(direction),vs_normal);
	return max(directionFinal2,0.f);
}

//sky color1:vec3(0.294f,0.376f,0.525f)
//sky color2:vec3(0.333f,0.451f,0.635f)

/* const matrices for 3d rotation */
const mat3 rot1 = mat3(-0.37f, 0.36f, 0.85f,-0.14f,-0.93f, 0.34f,0.92f, 0.01f,0.4f);
const mat3 rot2 = mat3(-0.55f,-0.39f, 0.74f, 0.33f,-0.91f,-0.24f,0.77f, 0.12f,0.63f);
const mat3 rot3 = mat3(-0.71f, 0.52f,-0.47f,-0.08f,-0.72f,-0.68f,-0.7f,-0.45f,0.56f);

/* directional artifacts can be reduced by rotating each octave */
//float fbm(vec3 p) {
//    
//    float f = 0.5000 * texture(diffuse3D,p/128.f).r; p = p * 2.02f;
//    f += 0.2500 * texture(diffuse3D,p/128.f).r; p = p * 2.03f;
//    f += 0.1250 * texture(diffuse3D,p/128.f).r; p = p * 2.01f;
//    f += 0.0625 * texture(diffuse3D,p/128.f).r;
//    return f / 0.9375;
//}
float fbm(vec3 p) {
    return 1.39f*(texture(diffuse3D,0.000002111276041665f*p).r + texture(diffuse3D,0.0000001051142446298915f*p).r)-1.2075f;
}
const vec3 skyColor1=vec3(0.315992315f,0.458397805f,0.6951068415f);//mix(vec3(0.35079825f,0.4746775f,0.66865325f),vec3(0.1875f,0.4f,0.79f),0.218f);
const vec3 skyColor2=vec3(0.2254862365f,0.2647329635f,0.339090285975f);//mix(vec3(0.23607575f,0.22702425f,0.2133891125f),vec3(0.179f,0.436f,0.76f),0.218f);
const vec3 skyColor3=vec3(0.31780831585f,0.399631678f,0.523712880634f);//mix(vec3(0.354134675f,0.399529f,0.449479387f),vec3(0.179f,0.436f,0.76f),0.218f);
const vec3 skyColor4=vec3(0.3568458145f,0.467096344073f,0.63732673439f);//mix(vec3(0.40405475f,0.4858009515f,0.594765645f),vec3(0.179f,0.436f,0.76f),0.218f);
const vec3 skyColor5=vec3(0.44917567171975f,0.587810857925f,0.8254787535f);//mix(vec3(0.522123621125f,0.6401673375f,0.83536925f),vec3(0.179f,0.436f,0.76f),0.218f);
vec3 global_sky_color()
{
    float sunLightHeight=-normalize(directionLight4D.direction4D).y;
    if(sunLightHeight<-0.07f)
    {
    return skyColor1;
    }
    else if(sunLightHeight>=-0.07f&&sunLightHeight<0.f)
    {
    return mix(skyColor1,skyColor2,(sunLightHeight+0.07f)/0.07f);
    }
    else if(sunLightHeight>=0.f&&sunLightHeight<0.1f)
    {
    return mix(skyColor2,skyColor3,(sunLightHeight)/0.1f);
    }
    else if(sunLightHeight>=0.1f&&sunLightHeight<0.2f)
    {
    return mix(skyColor3,skyColor4,(sunLightHeight-0.1f)/0.1f);
    }
    else if(sunLightHeight>=0.2f)
    {
    return mix(skyColor4,skyColor5,(sunLightHeight-0.2f)/0.8f);
    }
}
vec3 ground_color()
{
vec3 globalSkyColor=global_sky_color();
vec3 groundColor=vec3(0.4f,0.510f,0.248f)*(directionLight4D.color*directionLight4D.intensity*calculate_direction(vec4(0.f,1.f,0.f,0.f),directionLight4D.direction4D)+globalSkyColor);
vec4 V = direction;
    if(isAreaDeleting)
   {
   if(V.y<0.f)
   {
      vec4 groundCoordinate=-cameraPos.y*V/V.y+cameraPos;
      int isDeleteArea=int(255.f*texelFetch(deleteMap3D,ivec3(groundCoordinate.xzw+vec3(64.f)),0).r);
      if(isDeleteArea==1){
      groundColor+=texture(area,groundCoordinate.xzw).xyz;
   }
   }
   }
   if(isSkyBoxFog==true)
    {
   float viewDistance=cameraPos.y/(-V.y);
   float transmittance=exp(-0.00003861f*viewDistance);
   vec3 groundColor2=0.55f*groundColor/vec3(0.4f,0.510f,0.248f);
   vec3 fogColor=(globalSkyColor+groundColor2)/2.f+directionLight4D.color/PI;
   groundColor=mix(fogColor,groundColor,transmittance);
   }
   return groundColor;
}
vec3 stars_color()
{
return texture(starsField3D, vs_texcoord).xyz;
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define atmosphereHeight 8292.f-max(cameraPos.y,64.f)
#define earthRadius 6371000.f
#define mieHeight 1200.f
//http://www.vendian.org/mncharity/dir3/starcolor/
#define sunColor pow(vec3(0xff,0xf5,0xf2)/255.f,vec3(2.2f))
#define ozoneHeight 30000.f
// http://skyrenderer.blogspot.com/2012/10/ozone-absorption.html
// https://www.spectroscopyeurope.com/article/new-broadband-high-resolution-ozone-absorption-cross-sections
#define ozoneCoefficient (vec3(3.426f, 8.298f, 0.356f) * 6e-5f / 100.f)
#define mieCoefficient 3.3e-6f // adjust for foggier look
#define earthAlbedo pow(vec3(0x99f,0x92f,0x80f)/255.f,vec3(2.2f))

// ( Riley, Ebert, Kraus )
//#define rayleighCoefficient vec3(5.8e-6  , 1.35e-5 , 3.31e-5 )
// ( Bucholtz )
//#define rayleighCoefficient vec3(4.847e-6, 1.149e-5, 2.87e-5 ) 
// ( Thalman, Zarzana, Tolbert, Volkamer )
//#define rayleighCoefficient vec3(5.358e-6, 1.253e-5, 3.062e-5)
// ( Penndorf )
#define rayleighCoefficient vec3(5.178e-6f, 1.226e-5f, 3.06e-5f )

#define up vec4(0.f,1.f,0.f,0.f)

//b = dotup
vec3 get_sky_thicknesses(float b){
    const vec4 sr = earthRadius + vec4(
        atmosphereHeight,
        mieHeight,
        ozoneHeight,
        ozoneHeight + atmosphereHeight
    );
    b*=earthRadius;
    const float r2 = earthRadius * earthRadius;
    vec4 z = sqrt( sr * sr + (b * b - r2) );
    return vec3(b+z.xy, z.w-z.z);
}

// Improved Rayleigh phase for single scattering
// https://old.cescg.org/CESCG-2009/papers/PragueCUNI-Elek-Oskar09.pdf
// note: integral from -1 to 1 of function in the paper is 2.24f
#define phaseRayleigh(a) (( 0.4f * (a) + 1.12f )/2.24f)
//#define phaseRayleigh(a) ((3.f/8.f)*(1.+(a)*(a)))

// (Henyey Greenstein)
// https://www.astro.umd.edu/~jph/HG_note.pdf
float phaseg(float x,float g){
    const float  b = 0.5f;
    float a = inversesqrt(1.f+g*g-2.f*g*x);
	return b*(1.f-g*g)*a*a*a;
}
float phase_mie(const float VdotL, const float depth){
    //curve fit with turingbot
    float g = atan(sin(pow(0.7f,depth*mieCoefficient)));
    return phaseg(VdotL, g);
}


// https://iquilezles.org/articles/sphereshadow
float sph_soft_shadow(vec4 position,vec4 L){
    const float k = 5.f;
    //vec4 sph = vec4(-up*earthRadius,earthRadius);
    vec4 oc = position + up * earthRadius;
    float b = dot( oc, L );
    float c = dot( oc, oc ) - earthRadius*earthRadius;
    float h = b*b - c;
    
    float d = -earthRadius + sqrt( max(0.0,earthRadius*earthRadius-h));
    float t = -b - sqrt( max(0.f,h) );
    return (t<0.f) ? 1.f : smoothstep(0.f, 1.f, 2.5f*k*d/t );
}

float get_cloud_distance(vec4 ray,float radius,float height)
{
return sqrt(radius*radius*ray.y*ray.y+2.f*height*radius+height*height)-radius*ray.y;
}

vec3 linearToSrgb(const vec3 x){
    return sqrt((-2.8450663e-1f*x+1.2580714f)*x-2.4727747e-3f);
}

vec3 get_sky(const vec4 V, const vec4 L) {
    vec3 color3=vec3(0.f);
    float VdotUp = -V.y;
    float LdotUp = -L.y;
    if(VdotUp<0.02f)
    {
    if(LdotUp<0.15f)
    {
      const mat3 coeffs = mat3(
        rayleighCoefficient      ,
        vec3(mieCoefficient), // mie absorbs (Bruneton)
        ozoneCoefficient
    );

    vec3 thicknesses = get_sky_thicknesses(VdotUp);
    float VdotL = dot(V, L);
    float phaseMie=phase_mie(VdotL, thicknesses.y);
    vec3 rayleighScatter =(thicknesses.x * phaseRayleigh(VdotL))          * rayleighCoefficient;
    float     mieScatter = thicknesses.y * phaseMie *      mieCoefficient;

	vec3 scattering = rayleighScatter + mieScatter;
    
    vec3 sunCoeff = coeffs * get_sky_thicknesses(LdotUp);
    vec3 viewCoeff = coeffs * thicknesses;
    vec3 absorption = (exp(-viewCoeff)-exp(-sunCoeff)) / (sunCoeff - viewCoeff);
    
    //  integral of x from 0 to 1
    //  exp( -a*x - b*(1-x) )
    //
    //  e?? - e??
    // ---------
    //  (a - b) 
    
    float earthShadow = sph_soft_shadow(thicknesses.x*V,L);
    
    //if(VdotUp>0.f)return ground_color();
    if(atmosphereHeight>0.f)
    color3=sunColor * scattering * absorption * earthShadow;
    color3=1.4f*linearToSrgb(color3);
    //color3=max(color3,0.f);
    //if(-LdotUp<0.f)
    //{
    //    color3 += clamp(LdotUp/0.15f,0.f,1.f) * stars_color(V);
    //}
    if(VdotL>0.7f)
    {
    color3+=min(1.5042f*directionLight4D.color/(6000.f*(1.f-VdotL))/2.f,vec3(10.f));
        if(VdotL>0.99999f)
    {
    color3+=1600.f*directionLight4D.color;
    }
    }
    color3*=1.273525f;
    color3=max(color3,0.f);
    //vec3(0.1875f,0.4f,0.79f)
    float secondaryScatteringBrightness=smoothstep(0.15f,0.f,LdotUp);
    color3 = mix(color3,secondaryScatteringBrightness*vec3(0.1875f,0.4f,0.79f),0.218f);
    if(VdotUp<0.02f)
    {
    if(isCloud==true||isSkyBoxFog==true)
    {
    cloudDistance=get_cloud_distance(V,earthRadius,10000.f - cameraPos.y);
    }
    if(isCloud==true)
    {
    vec4 cloudPlaneCoordinate=cloudDistance*V + cameraPos;
    float cloudDensity = max(0.5f * smoothstep(0.55f, 0.85f, -0.09f+1.53f*fbm(cloudPlaneCoordinate.xzw+vec3(288.65f*iTime,0.f,288.65f*iTime)/10000.f)),0.f);
    if(cloudDensity>0.f){
    vec3 sunCoeff2 = sunCoeff/3.95f;
    vec3 viewCoeff2 = viewCoeff/3.95f;
    vec3 absorption2 = (exp(-viewCoeff2)-exp(-sunCoeff2)) / (sunCoeff2 - viewCoeff2);
    vec3 cloudColor3=(1.2282825f*vec3(directionLight4D.color.g/1.1f)*(1.171897656f+0.088156f*directionLight4D.color*phaseMie/1.1f))*linearToSrgb(absorption2 *vec3(1.f,0.95f,1.f));                                 //1.0525f*1.1f*1.09f*1.15f*1.044503f*1.38/1.4f/1.275 //// 1.0525f*1.1f*1.09f*1.15f*1.044503f*1.38/1.4f*0.059
    transmittance=exp(-0.000003675f*cloudDistance); 
    color3=mix(color3,max(cloudColor3/exp(max(cloudDensity/3.2f,0.f)),vec3(0.f)),cloudDensity*transmittance);
    }
    }
    if(isSkyBoxFog==true)
    {
    vec3 globalSkyColor=global_sky_color();
    vec3 groundColor=0.55f*(directionLight4D.color*directionLight4D.intensity*calculate_direction(vec4(0.f,1.f,0.f,0.f),directionLight4D.direction4D)+globalSkyColor);
    vec3 fogColor=secondaryScatteringBrightness*0.8875f*((globalSkyColor+groundColor)/2.f+directionLight4D.color/PI);
    transmittance=exp(-0.0000018375f*cloudDistance); 
    color3=mix(fogColor,color3,transmittance);
    }
    }
    }
    if(VdotUp<=0.f)
    {
       return color3;
    }
    else if(VdotUp<0.02f&&VdotUp>0.f)
	{
	   return mix(ground_color(),color3,100.f*(-VdotUp+0.02)/2.f);
	}
    }  
    else
    {
    return ground_color();
    }
}

    //extreme=abs(vs_position.x+vs_position.y+vs_position.z+vs_position.w)/4.f;
	//direction=normalize(vs_position/extreme);

void main()
{
	direction=normalize(vs_position);
    if(type==0) color=vec4(get_sky(direction,-directionLight4D.direction4D),1.f);
    else if(type==1) color=vec4(stars_color(),1.f);
    color*=paintingColor;
	fs_color = color;
}